## 最適化案リスト
| #  | 施策                                              | 詳細                                                                                                        | 速度向上  | 実装の手軽さ | 現行コードへの適応度 |
| -- | ----------------------------------------------- | --------------------------------------------------------------------------------------------------------- | ----- | ------ | ---------- |
| 1  | `_sor_iteration`・`compute_residual` のNumba JIT化 | 3重ループ＋多量の算術処理をそのままJITコンパイルしてPythonループのオーバーヘッドを削減する。:codex-file-citation:codex-file-citation               | ★★★★☆ | ★★☆☆☆  | ★★★★☆      |
| 2  | 方向ごとの調和平均係数を事前計算・再利用                            | 各格子点で毎回 `eps_*` と係数 `ax`〜`bz` を再計算しているので、境界条件が変わらない区間では事前計算してキャッシュする。:codex-file-citation                 | ★★★☆☆ | ★★☆☆☆  | ★★★★☆      |
| 3  | Red-Black SOR（チェッカーボード更新）への変更                   | 現状は逐次更新でデータ依存が強い。Red-Black順なら各色を並列化しやすく収束も改善されることが多い。:codex-file-citation                                 | ★★★★☆ | ★★★☆☆  | ★★★☆☆      |
| 4  | マルチグリッド前処理や階層グリッド併用                             | 純SORの収束を加速するため、粗グリッドでの補正を組み合わせる。SORを内側スムーサとして利用できる。:codex-file-citation                                   | ★★★★★ | ★☆☆☆☆  | ★★☆☆☆      |
| 5  | 残差計算の頻度削減または差分更新                                | 毎反復で全格子を走査して残差を再計算している。一定間隔で評価、または更新点のみで差分残差を更新するとコスト減。:codex-file-citation                               | ★★★☆☆ | ★★★☆☆  | ★★★★☆      |
| 6  | Dirichlet境界の固定領域をマスクし一括代入                       | 毎回 `apply_boundary_conditions` で配列コピーと分岐を行っている。事前に固定インデックスを抽出し反復中は直接代入・コピー削減する。:codex-file-citation       | ★★☆☆☆ | ★★★☆☆  | ★★★★☆      |
| 7  | 反復内で `phi` をインプレース更新しコピー削減                      | `apply_boundary_conditions` などで `phi.copy()` を生成している箇所を可能な範囲でインプレース化し、メモリアロケーションを減らす。:codex-file-citation | ★★☆☆☆ | ★★★☆☆  | ★★★☆☆      |
| 8  | GPU対応（CuPy/pyopencl）による並列化                      | NumPy互換APIで3D配列演算をGPUに移し、密な格子計算を高速化。SORの逐次性は残るが一部操作をGPU化可能。:codex-file-citation:codex-file-citation       | ★★★★☆ | ★★☆☆☆  | ★★☆☆☆      |
| 9  | オーバーリラクゼーション係数の自動調整                             | 現在は固定 `omega`。反復中に残差に応じて `omega` を更新すると収束までの反復数を減らせる。:codex-file-citation:codex-file-citation             | ★★★☆☆ | ★★★☆☆  | ★★★☆☆      |
| 10 | 反復前の初期解を物理的に妥当な近似で与える                           | 現在はゼロ初期化。解析解や前回結果を初期値に使えば必要反復回数が減る。:codex-file-citation                                                   | ★★☆☆☆ | ★★★★☆  | ★★★★★      |


## 優先順位
1. 方向ごとの調和平均係数を事前計算・再利用（提案2）
速度向上:★★★☆☆ / 手軽さ:★★☆☆☆ / 適応度:★★★★☆
即効性と実装コストのバランスがよく、現行構造にも自然に組み込めるため最優先。

2. 残差計算の頻度削減または差分更新（提案5）
速度向上:★★★☆☆ / 手軽さ:★★★☆☆ / 適応度:★★★★☆
既存ロジックを大きく崩さず計算量を削減でき、優先度は非常に高い。

3. _sor_iteration・compute_residualのNumba JIT化（提案1）
速度向上:★★★★☆ / 手軽さ:★★☆☆☆ / 適応度:★★★★☆
効果が大きくコード変更も局所的。導入準備（Numba依存追加など）は必要だが価値大。

4. 反復内でphiをインプレース更新（提案7）
速度向上:★★☆☆☆ / 手軽さ:★★★☆☆ / 適応度:★★★☆☆
メモリアロケーション削減で地味だが着実。上位3件に続けて着手しやすい。

5. Dirichlet境界の固定領域をマスクし一括代入（提案6）
速度向上:★★☆☆☆ / 手軽さ:★★★☆☆ / 適応度:★★★★☆
実装は比較的簡単で、境界条件の適用コストを下げられる。

6. オーバーリラクゼーション係数の自動調整（提案9）
速度向上:★★★☆☆ / 手軽さ:★★★☆☆ / 適応度:★★★☆☆
調整ロジックの設計が鍵だが、収束反復数削減による効果が期待できる。

7. 初期解を物理的に妥当な近似で与える（提案10）
速度向上:★★☆☆☆ / 手軽さ:★★★★☆ / 適応度:★★★★★
実装は簡単だが、初期値が得られる場合に限られるため優先度は中位。

8. Red-Black SORへの変更（提案3）
速度向上:★★★★☆ / 手軽さ:★★★☆☆ / 適応度:★★★☆☆
ループ構造の組み替えが必要。並列化も視野に入るが設計変更が大きいため後回し。

9. GPU対応（提案8）
速度向上:★★★★☆ / 手軽さ:★★☆☆☆ / 適応度:★★☆☆☆
大幅高速化の潜在力はあるが、環境依存や実装コストが高く優先度は低め。

10. マルチグリッド前処理や階層グリッド併用（提案4）
速度向上:★★★★★ / 手軽さ:★☆☆☆☆ / 適応度:★★☆☆☆
最も効果的な可能性はあるが大規模改修と検証が必要なため、基盤最適化後の長期課題として位置づけ。

